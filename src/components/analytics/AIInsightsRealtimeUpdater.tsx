import React, { useEffect } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from '@/context/AuthContext';
import { useQueryClient } from '@tanstack/react-query';
import { useToast } from '@/hooks/use-toast';
import { Badge } from '@/components/ui/badge';
import { Brain, Wifi, WifiOff, Zap } from 'lucide-react';

interface AIInsightsRealtimeUpdaterProps {
  className?: string;
  showConnectionStatus?: boolean;
}

export const AIInsightsRealtimeUpdater = ({ 
  className, 
  showConnectionStatus = true 
}: AIInsightsRealtimeUpdaterProps) => {
  const { user } = useAuth();
  const queryClient = useQueryClient();
  const { toast } = useToast();
  const [connectionStatus, setConnectionStatus] = React.useState<'connected' | 'disconnected' | 'connecting'>('connecting');
  const [insightCount, setInsightCount] = React.useState(0);

  useEffect(() => {
    if (!user?.id) return;

    setConnectionStatus('connecting');

    // Set up real-time subscription for learning insights updates
    const insightsChannel = supabase
      .channel(`learning-insights-${user.id}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'learning_insights',
          filter: `user_id=eq.${user.id}`
        },
        (payload) => {
          console.log('Real-time insights update:', payload);
          
          // Invalidate relevant queries to refetch data
          queryClient.invalidateQueries({ 
            queryKey: ['learning-insights', user.id] 
          });
          
          if (payload.eventType === 'INSERT') {
            setInsightCount(prev => prev + 1);
            
            toast({
              title: "ðŸ§  New AI Insights Available",
              description: "Your learning analysis has been updated with fresh insights.",
              duration: 5000,
            });
          }
        }
      )
      .subscribe((status) => {
        console.log('Insights channel status:', status);
        setConnectionStatus(status === 'SUBSCRIBED' ? 'connected' : 'disconnected');
      });

    // Set up subscription for analytics data changes that trigger AI updates
    const analyticsChannel = supabase
      .channel(`user-analytics-${user.id}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'quiz_attempts',
          filter: `user_id=eq.${user.id}`
        },
        (payload) => {
          console.log('Real-time quiz attempt update:', payload);
          
          // Invalidate analytics queries
          queryClient.invalidateQueries({ 
            queryKey: ['analytics-data', user.id] 
          });
          queryClient.invalidateQueries({ 
            queryKey: ['learning-time-patterns', user.id] 
          });
          queryClient.invalidateQueries({ 
            queryKey: ['knowledge-gaps', user.id] 
          });

          // Auto-generate insights after significant activity
          if (payload.eventType === 'INSERT') {
            setTimeout(() => {
              // Trigger background insight generation
              supabase.functions.invoke('generate-learning-insights', {
                body: { 
                  userId: user.id, 
                  analysisType: 'comprehensive_insights',
                  autoGenerated: true
                }
              }).then(() => {
                console.log('Auto-generated insights triggered');
              }).catch(error => {
                console.error('Failed to auto-generate insights:', error);
              });
            }, 2000);
          }
        }
      )
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'user_progress',
          filter: `user_id=eq.${user.id}`
        },
        (payload) => {
          console.log('Real-time progress update:', payload);
          
          // Invalidate analytics queries
          queryClient.invalidateQueries({ 
            queryKey: ['analytics-data', user.id] 
          });
          queryClient.invalidateQueries({ 
            queryKey: ['learning-time-patterns', user.id] 
          });
        }
      )
      .subscribe();

    // Set up subscription for gamification updates
    const gamificationChannel = supabase
      .channel(`user-gamification-${user.id}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'user_gamification',
          filter: `user_id=eq.${user.id}`
        },
        (payload) => {
          console.log('Real-time gamification update:', payload);
          
          // Invalidate analytics queries
          queryClient.invalidateQueries({ 
            queryKey: ['analytics-data', user.id] 
          });

          // Generate insights after major achievements
          if (payload.eventType === 'UPDATE' && payload.new?.level > payload.old?.level) {
            toast({
              title: "ðŸŽ‰ Level Up! Generating New Insights",
              description: "AI is analyzing your improved performance patterns.",
              duration: 4000,
            });
          }
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(insightsChannel);
      supabase.removeChannel(analyticsChannel);
      supabase.removeChannel(gamificationChannel);
      setConnectionStatus('disconnected');
    };
  }, [user?.id, queryClient, toast]);

  if (!showConnectionStatus) {
    return null;
  }

  const getStatusColor = () => {
    switch (connectionStatus) {
      case 'connected': return 'default';
      case 'connecting': return 'secondary';
      case 'disconnected': return 'destructive';
      default: return 'secondary';
    }
  };

  const getStatusIcon = () => {
    switch (connectionStatus) {
      case 'connected': return <Wifi className="h-3 w-3" />;
      case 'connecting': return <Brain className="h-3 w-3 animate-pulse" />;
      case 'disconnected': return <WifiOff className="h-3 w-3" />;
      default: return <Brain className="h-3 w-3" />;
    }
  };

  const getStatusText = () => {
    switch (connectionStatus) {
      case 'connected': return insightCount > 0 ? `AI Active (${insightCount})` : 'AI Connected';
      case 'connecting': return 'Connecting...';
      case 'disconnected': return 'Offline';
      default: return 'Unknown';
    }
  };

  return (
    <div className={className}>
      <Badge variant={getStatusColor()} className="flex items-center gap-1 text-xs">
        {getStatusIcon()}
        {getStatusText()}
        {connectionStatus === 'connected' && insightCount > 0 && (
          <Zap className="h-2 w-2 text-yellow-500 animate-pulse ml-1" />
        )}
      </Badge>
    </div>
  );
};